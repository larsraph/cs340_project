/* Generated by AI then modified by me. */

import { createResource, For, Suspense, createSignal, Setter, createEffect, createMemo } from 'solid-js';
import "./DbFetchTable.css";


type DbFetchTableProps = {
  table: string;
};

const formatColumnHeader = (key: string): string => {
  return key
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
};

type DataRowProps = {
  rowIndex: number;
  row: Record<string, any>;
  columns: string[];
  editingId: number | null;
  setEditingId: Setter<number | null>;
  onDelete: (index: number) => void;
  onUpdate: (index: number, data: Record<string, any>) => void;
};

const DataRow = (props: DataRowProps) => {
  const [editData, setEditData] = createSignal<Record<string, any>>({});
  const isEditing = createMemo(() => props.editingId === props.rowIndex);

  const handleEditClick = () => {
    if (isEditing()) {
      props.setEditingId(null);
    } else {
      const data: Record<string, any> = {};
      props.columns.forEach(col => {
        data[col] = props.row[col];
      });
      setEditData(data);
      props.setEditingId(props.rowIndex);
    }
  };

  const handleInputChange = (column: string, value: string) => {
    setEditData(prev => ({ ...prev, [column]: value }));
  };

  const handleDelete = () => {
    props.onDelete(props.rowIndex);
  };

  const handleSubmit = () => {
    props.onUpdate(props.rowIndex, editData());
    props.setEditingId(null);
  };

  return (
    <tr>
      <For each={props.columns}>
        {(column) => (
          <td>
            {isEditing() ? (
              <input
                type="text"
                value={editData()[column] || ''}
                onInput={(e) => handleInputChange(column, e.currentTarget.value)}
              />
            ) : (
              String(props.row[column])
            )}
          </td>
        )}
      </For>
      <td class="trash">
        <button onClick={handleDelete}>üóëÔ∏è</button>
        {isEditing() ? (
          <button onClick={handleSubmit}>‚úì</button>
        ) : (
          <button onClick={handleEditClick}>‚úèÔ∏è</button>
        )}
      </td>
    </tr>
  );
};

type FormRowProps = {
  columns: string[];
  onAddRow: (row: Record<string, any>) => void;
};

const FormRow = (props: FormRowProps) => {
  const [formData, setFormData] = createSignal<Record<string, string>>({});

  const handleInputChange = (column: string, value: string) => {
    setFormData(prev => ({ ...prev, [column]: value }));
  };

  const handleSubmit = () => {
    props.onAddRow(formData());
    setFormData({});
  };

  return (
    <tr class="form-row">
      <For each={props.columns}>
        {(column) => (
          <td>
            <input
              type="text"
              placeholder={formatColumnHeader(column)}
              value={formData()[column] || ''}
              onInput={(e) => handleInputChange(column, e.currentTarget.value)}
            />
          </td>
        )}
      </For>
      <td class="trash">
        <button onClick={handleSubmit}>‚úì</button>
      </td>
    </tr>
  );
};

const DbFetchTable = (props: DbFetchTableProps) => {
  const [editingId, setEditingId] = createSignal<number | null>(null);
  const [tableData, setTableData] = createSignal<Record<string, any>[]>([]);
  const [columns, setColumns] = createSignal<string[]>([]);

  const getApiUrl = (table: string): string => {
    if (import.meta.env.SSR) {
      // On the server, construct an absolute URL for SSR
      const port = process.env.PORT || process.env.VITE_PORT || '3000';
      return `http://localhost:${port}/api/${table}`;
    }
    // On the client, use relative URL which uses the current origin
    return `/api/${table}`;
  };

  const [data] = createResource(() => props.table, async (table) => {
    const response = await fetch(getApiUrl(table));
    if (!response.ok) {
      throw new Error(`Failed to fetch table data: ${response.statusText}`);
    }
    return response.json();
  });

  createEffect(() => {
    if (data()) {
      setTableData([...data()]);
      if (data().length > 0) {
        setColumns(Object.keys(data()[0]));
      }
    }
  });

  const handleDeleteRow = (index: number) => {
    setTableData(prev => prev.filter((_, i) => i !== index));
  };

  const handleUpdateRow = (index: number, newData: Record<string, any>) => {
    setTableData(prev => {
      const updated = [...prev];
      updated[index] = newData;
      return updated;
    });
  };

  const handleAddRow = (newRow: Record<string, any>) => {
    setTableData(prev => [...prev, newRow]);
  };

  return (
    <div class="table-container">
      <Suspense fallback={<p>Loading data...</p>}>
        {columns().length > 0 ? (
          <table class="db-table">
            <thead>
              <tr>
                <For each={columns()}>
                  {(key) => <th>{formatColumnHeader(key)}</th>}
                </For>
              </tr>
            </thead>
            <tbody>
              <For each={tableData()}>
                {(row, index) => (
                  <DataRow
                    rowIndex={index()}
                    row={row}
                    columns={columns()}
                    editingId={editingId()}
                    setEditingId={setEditingId}
                    onDelete={handleDeleteRow}
                    onUpdate={handleUpdateRow}
                  />
                )}
              </For>
              <FormRow columns={columns()} onAddRow={handleAddRow} />
            </tbody>
          </table>
        ) : (
          <p>No data available</p>
        )}
      </Suspense>
    </div>
  );
}

export default DbFetchTable;